<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<title>Voice Racing</title>
	<script type="text/javascript" src="js/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.CANVAS, '', { preload: preload, create: create, update: update, render: render});

function preload() {

    game.stage.backgroundColor = "CDE5FF";
	game.load.spritesheet('dude', 'assets/dude.png', 32, 48);
    game.load.image('land_1', 'assets/land_1.png');
    game.load.image('land_2', 'assets/land_2.png');

}


var player;
var player_height = 24;
var ground;
var ground_height = new Array(10000);
var ground_now = 0;
var fall_count = 0;
var fall_step = 6;
var alive = true;
var lose = 'YOU   LOSE';
var lose_style = {font: "65px Arial", fill: "#ff0044", align: "center"};
var index_text;
var height_text;
var movespeed = 5;
var bump_step = 5;
var bump_height = 5;
var trumble_step = 5;
var trumble_height = 5;

var next_gene_ground = 240; // index
var next_ground = 50;        // index
var space_width = 100;        // index

var movespeed_arr = new Array(5, 10, 20, 25);




//add---
var p1;
//add---

function create() {

    game.world.setBounds(0, 0, 5000000, 600);
    player = game.add.sprite(50, 500, 'dude');
    player.anchor.setTo(0.5, 1);
    player.animations.add('right', [5, 6, 7, 8], 10, true);
    player.animations.play('right');
    ground = game.add.group();

    ground.create(-2200, 500, 'land_1');
    for(var i=0;i<150;i++)
        ground_height[i] = 100;
    for(var i=150;i<100000;i++)
        ground_height[i] = 0;

    index_text = game.add.text(10, 10, ground_now);
    height_text = game.add.text(10, 50, ground_height[ground_now]);

    //add---
    toggleLiveInput();
    p1 = new Phaser.Point(50, 0);
    //add---
}



function update() {

    if (alive){
        compute_fall();
 //       falling();
 //       bumping();
 //       trumbling();
        ground.position.x -= 5 ;
        ground_now++;
        if(ground_now == 100000)
            ground_now = 0;
        fall_step++;
        if(fall_step == 100000)
            fall_step = 0;
        bump_step++;
        if(bump_step == 100000)
            bump_step = 0;
        trumble_step = bump_step;
        index_text.setText(ground_now);
        height_text.setText(ground_height[ground_now]);
    }
    else{
        game.add.text(200, 200, lose, lose_style);
    }

    if (ground_now == next_ground){
        create_ground();
    }


    //add---
    if ( (Math.abs(Math.abs(100-(median(pitchArray)-50))*(600/(150-50)) - p1.y)))
    {
        p1.y = Math.abs(100-(median(pitchArray)-50))*(600/(150-50));
        player.position.y = Math.abs(100-(median(pitchArray)-50))*(600/(150-50));
    }
    //add---

}


function render(){

    //add---
    game.context.fillStyle = 'rgb(255,0,0)';
    game.context.fillRect(p1.x, p1.y, 8, 8);
    //add---

}

function compute_fall(){
    if(ground_height[fall_step] == 0)
        fall_count++;
    else
        fall_count = 0;

}


function falling(){
    if(fall_count == 7){
        alive = false;
        game.time.events.repeat(10, 120, fall_down, this);
    }

}

function fall_down(){
    player.position.y += 5;
}

function bumping(){
    if(ground_height[bump_step]-ground_height[ground_now] > bump_height){
        alive = false;
        game.time.events.repeat(1, 10, rot_back, this);
    }
}

function rot_back(){
    player.angle-=6;
}

function trumbling(){
    if(ground_height[ground_now]-ground_height[trumble_step] > trumble_height){
        alive = false;
        game.time.events.repeat(1, 10, rot_front, this);
    }
}

function rot_front(){
    player.angle+=6;
}



function create_ground(){
    var y = game.world.randomY;
    ground.create(next_gene_ground*movespeed, 600-y, 'land_2');

    var len = 1000/movespeed;
    for(var i=0; i<len; i++){
        ground_height[i+next_gene_ground] = y;
    }

    next_ground += space_width+1000/movespeed;
    if(next_ground >= 100000)
        next_ground -= 100000;
    next_gene_ground += space_width+1000/movespeed;

}






window.AudioContext = window.AudioContext || window.webkitAudioContext;

var audioContext = new AudioContext();
var isPlaying = false;
var sourceNode = null;
var analyser = null;
var theBuffer = null;
var detectorElem,
    canvasContext,
    pitchElem,
    noteElem,
    detuneElem,
    detuneAmount;
var WIDTH = 300;
var CENTER = 150;
var HEIGHT = 42;
var confidence = 0;
var currentPitch = 0;

var pitchArray = [];

window.onload = function() {}

function error() {
    alert('Stream generation failed.');
}

function getUserMedia(dictionary, callback) {
    try {
        navigator.getUserMedia =
            navigator.getUserMedia ||
            navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia;
        navigator.getUserMedia(dictionary, callback, error);
    } catch (e) {
        alert('getUserMedia threw exception :' + e);
    }
}

function gotStream(stream) {
    // Create an AudioNode from the stream.
    var mediaStreamSource = audioContext.createMediaStreamSource(stream);

    // Connect it to the destination.
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 2048;
    mediaStreamSource.connect(analyser);
    updatePitch();
}

function toggleLiveInput() {
    getUserMedia({
        audio: true
    }, gotStream);
}

var rafID = null;
var tracks = null;
var buflen = 2048;
var buf = new Uint8Array(buflen);
var MINVAL = 134; // 128 == zero.  MINVAL is the "minimum detected signal" level.

var noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

function noteFromPitch(frequency) {
    var noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
    return Math.round(noteNum) + 69;
}

function frequencyFromNoteNumber(note) {
    return 440 * Math.pow(2, (note - 69) / 12);
}

function centsOffFromPitch(frequency, note) {
    return (1200 * Math.log(frequency / frequencyFromNoteNumber(note)) / Math.log(2));
}

function autoCorrelate(buf, sampleRate) {
    var MIN_SAMPLES = 4; // corresponds to an 11kHz signal
    var MAX_SAMPLES = 1000; // corresponds to a 44Hz signal
    var SIZE = 1000;
    var best_offset = -1;
    var best_correlation = 0;
    var second_best_correlation = 0;
    var second_best_offset = -1;
    var rms = 0;

    confidence = 0;
    currentPitch = 0;

    if (buf.length < (SIZE + MAX_SAMPLES - MIN_SAMPLES))
        return; // Not enough data

    for (var i = 0; i < SIZE; i++) {
        var val = (buf[i] - 128) / 128;
        rms += val * val;
    }
    rms = Math.sqrt(rms / SIZE);

    for (var offset = MIN_SAMPLES; offset <= MAX_SAMPLES; offset++) {
        var correlation = 0;

        for (var i = 0; i < SIZE; i++) {
            correlation += (buf[i] - 128) * (buf[i + offset] - 128);
        }
        //correlation = 1 - (correlation/SIZE);
        if ( (correlation - best_correlation) > 3000 ) {
            second_best_correlation = best_correlation;
            second_best_offset = best_offset;
            best_correlation = correlation;
            best_offset = offset;
        }
    }
    if ((rms > 0.1) && (best_correlation > 0.01)) {
        confidence = (second_best_correlation-best_correlation) * rms * 10000;
        currentPitch = sampleRate / best_offset;

        if (currentPitch > 40 && currentPitch < 1000) {
            //console.log("f = " + sampleRate / best_offset + "Hz (rms: " + rms + " confidence: " + best_correlation + ")")

            if (pitchArray.length >= 5) {
                pitchArray.splice(0, 1);
                pitchArray.push(currentPitch);

                console.log(second_best_offset + ", " + second_best_correlation +",b"+best_offset+","+best_correlation);

            } else {
                pitchArray.push(currentPitch);
            }

            console.log("median = ", median(pitchArray));
        }

    }
    //  var best_frequency = sampleRate/best_offset;
}

function updatePitch(time) {
    var cycles = new Array;
    analyser.getByteTimeDomainData(buf);

    // possible other approach to confidence: sort the array, take the median; go through the array and compute the average deviation
    autoCorrelate(buf, audioContext.sampleRate);

    //  detectorElem.className = (confidence>50)?"confident":"vague";

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = window.webkitRequestAnimationFrame;
    rafID = window.requestAnimationFrame(updatePitch);
}

function median(array) {

    var values = array.slice(0);

    values.sort(function(a, b) {
        return a - b;
    });
    //console.log("sort", values);
    var half = Math.floor(values.length / 2);

    if (values.length % 2)
        return values[half];
    else
        return (values[half - 1] + values[half]) / 2.0;
}

</script>

</body>
</html>